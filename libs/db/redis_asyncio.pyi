# Type stubs for redis.asyncio
from typing import Any, Optional, Union, Dict, List, Tuple, TypeVar, Generic
from typing_extensions import Self

_VT = TypeVar('_VT')

class Redis(Generic[_VT]):
    def __init__(
        self,
        host: str = "localhost",
        port: int = 6379,
        db: int = 0,
        password: Optional[str] = None,
        socket_timeout: Optional[float] = None,
        socket_connect_timeout: Optional[float] = None,
        socket_keepalive: bool = False,
        socket_keepalive_options: Optional[Dict[str, int]] = None,
        connection_pool: Optional[Any] = None,
        unix_socket_path: Optional[str] = None,
        encoding: str = "utf-8",
        encoding_errors: str = "strict",
        charset: Optional[str] = None,
        errors: Optional[str] = None,
        decode_responses: bool = False,
        retry_on_timeout: bool = False,
        retry_on_error: Optional[List[Exception]] = None,
        ssl: bool = False,
        ssl_keyfile: Optional[str] = None,
        ssl_certfile: Optional[str] = None,
        ssl_cert_reqs: Optional[str] = None,
        ssl_ca_certs: Optional[str] = None,
        ssl_check_hostname: bool = False,
        max_connections: Optional[int] = None,
        single_connection_client: bool = False,
        health_check_interval: int = 0,
        client_name: Optional[str] = None,
        username: Optional[str] = None,
        retry: Optional[Any] = None,
        redis_connect_func: Optional[Any] = None,
        credential_provider: Optional[Any] = None,
        protocol: int = 2,
        **kwargs: Any
    ) -> None: ...

    @classmethod
    def from_url(
        cls,
        url: str,
        *,
        encoding: str = "utf-8",
        encoding_errors: str = "strict",
        decode_responses: bool = False,
        db: Optional[int] = None,
        password: Optional[str] = None,
        socket_timeout: Optional[float] = None,
        socket_connect_timeout: Optional[float] = None,
        socket_keepalive: bool = False,
        socket_keepalive_options: Optional[Dict[str, int]] = None,
        retry_on_timeout: bool = False,
        retry_on_error: Optional[List[Exception]] = None,
        ssl_cert_reqs: Optional[str] = None,
        ssl_ca_certs: Optional[str] = None,
        ssl_certfile: Optional[str] = None,
        ssl_keyfile: Optional[str] = None,
        ssl_check_hostname: bool = False,
        health_check_interval: int = 0,
        client_name: Optional[str] = None,
        username: Optional[str] = None,
        retry: Optional[Any] = None,
        redis_connect_func: Optional[Any] = None,
        credential_provider: Optional[Any] = None,
        protocol: int = 2,
        **kwargs: Any
    ) -> Self: ...

    async def get(self, key: str) -> Optional[_VT]: ...
    async def set(
        self,
        key: str,
        value: _VT,
        ex: Optional[Union[int, float]] = None,
        px: Optional[int] = None,
        nx: bool = False,
        xx: bool = False,
        keepttl: bool = False,
        get: bool = False,
        exat: Optional[int] = None,
        pxat: Optional[int] = None,
    ) -> Optional[_VT]: ...
    
    async def delete(self, *keys: str) -> int: ...
    async def exists(self, *keys: str) -> int: ...
    
    async def hget(self, name: str, key: str) -> Optional[_VT]: ...
    async def hset(self, name: str, key: str, value: _VT) -> int: ...
    async def hdel(self, name: str, *keys: str) -> int: ...
    async def hgetall(self, name: str) -> Dict[str, _VT]: ...
    async def hmget(self, name: str, keys: List[str]) -> List[Optional[_VT]]: ...
    async def hmset(self, name: str, mapping: Dict[str, _VT]) -> bool: ...
    async def hincrby(self, name: str, key: str, amount: int = 1) -> int: ...
    async def hincrbyfloat(self, name: str, key: str, amount: float = 1.0) -> float: ...
    async def hexists(self, name: str, key: str) -> bool: ...
    async def hkeys(self, name: str) -> List[str]: ...
    async def hvals(self, name: str) -> List[_VT]: ...
    async def hlen(self, name: str) -> int: ...
    
    async def lpush(self, name: str, *values: _VT) -> int: ...
    async def rpush(self, name: str, *values: _VT) -> int: ...
    async def lpop(self, name: str, count: Optional[int] = None) -> Union[Optional[_VT], List[_VT]]: ...
    async def rpop(self, name: str, count: Optional[int] = None) -> Union[Optional[_VT], List[_VT]]: ...
    async def llen(self, name: str) -> int: ...
    async def lrange(self, name: str, start: int, end: int) -> List[_VT]: ...
    async def ltrim(self, name: str, start: int, end: int) -> bool: ...
    async def lindex(self, name: str, index: int) -> Optional[_VT]: ...
    async def lset(self, name: str, index: int, value: _VT) -> bool: ...
    async def lrem(self, name: str, count: int, value: _VT) -> int: ...
    async def linsert(self, name: str, where: str, refvalue: _VT, value: _VT) -> int: ...
    
    async def sadd(self, name: str, *values: _VT) -> int: ...
    async def srem(self, name: str, *values: _VT) -> int: ...
    async def smembers(self, name: str) -> set[_VT]: ...
    async def sismember(self, name: str, value: _VT) -> bool: ...
    async def scard(self, name: str) -> int: ...
    async def spop(self, name: str, count: Optional[int] = None) -> Union[Optional[_VT], set[_VT]]: ...
    async def srandmember(self, name: str, number: Optional[int] = None) -> Union[Optional[_VT], List[_VT]]: ...
    
    async def zadd(self, name: str, mapping: Dict[_VT, float], nx: bool = False, xx: bool = False, ch: bool = False, incr: bool = False) -> Union[int, float]: ...
    async def zrem(self, name: str, *values: _VT) -> int: ...
    async def zrange(self, name: str, start: int, end: int, desc: bool = False, withscores: bool = False, score_cast_func: Any = float) -> List[Union[_VT, Tuple[_VT, float]]]: ...
    async def zrevrange(self, name: str, start: int, end: int, withscores: bool = False, score_cast_func: Any = float) -> List[Union[_VT, Tuple[_VT, float]]]: ...
    async def zrank(self, name: str, value: _VT) -> Optional[int]: ...
    async def zrevrank(self, name: str, value: _VT) -> Optional[int]: ...
    async def zscore(self, name: str, value: _VT) -> Optional[float]: ...
    async def zcount(self, name: str, min: Union[float, str], max: Union[float, str]) -> int: ...
    async def zcard(self, name: str) -> int: ...
    async def zincrby(self, name: str, amount: float, value: _VT) -> float: ...
    
    async def expire(self, name: str, time: int) -> bool: ...
    async def expireat(self, name: str, when: int) -> bool: ...
    async def ttl(self, name: str) -> int: ...
    async def pttl(self, name: str) -> int: ...
    async def persist(self, name: str) -> bool: ...
    
    async def ping(self, **kwargs: Any) -> _VT: ...
    async def echo(self, value: _VT) -> _VT: ...
    async def time(self) -> List[int]: ...
    async def info(self, section: Optional[str] = None) -> Dict[str, Any]: ...
    async def client_list(self, _type: Optional[str] = None, client_id: Optional[List[int]] = None) -> List[Dict[str, Any]]: ...
    async def client_getname(self) -> Optional[_VT]: ...
    async def client_setname(self, name: str) -> bool: ...
    
    async def flushdb(self, asynchronous: bool = False) -> bool: ...
    async def flushall(self, asynchronous: bool = False) -> bool: ...
    
    async def keys(self, pattern: str = "*") -> List[str]: ...
    async def scan(self, cursor: int = 0, match: Optional[str] = None, count: Optional[int] = None, _type: Optional[str] = None) -> Tuple[int, List[str]]: ...
    
    async def eval(self, script: str, numkeys: int, *keys_and_args: Any) -> Any: ...
    async def evalsha(self, sha: str, numkeys: int, *keys_and_args: Any) -> Any: ...
    
    async def select(self, index: int) -> bool: ...
    async def move(self, name: str, db: int) -> bool: ...
    
    async def incr(self, name: str, amount: int = 1) -> int: ...
    async def incrby(self, name: str, amount: int = 1) -> int: ...
    async def incrbyfloat(self, name: str, amount: float = 1.0) -> float: ...
    async def decr(self, name: str, amount: int = 1) -> int: ...
    async def decrby(self, name: str, amount: int = 1) -> int: ...
    async def append(self, key: str, value: _VT) -> int: ...
    async def substr(self, name: str, start: int, end: int = -1) -> _VT: ...
    async def getrange(self, key: str, start: int, end: int) -> _VT: ...
    async def setrange(self, name: str, offset: int, value: _VT) -> int: ...
    async def getbit(self, name: str, offset: int) -> int: ...
    async def setbit(self, name: str, offset: int, value: int) -> int: ...
    async def bitcount(self, key: str, start: Optional[int] = None, end: Optional[int] = None, mode: str = "byte") -> int: ...
    async def bitop(self, operation: str, dest: str, *keys: str) -> int: ...
    
    async def strlen(self, name: str) -> int: ...
    
    async def mget(self, keys: List[str]) -> List[Optional[_VT]]: ...
    async def mset(self, mapping: Dict[str, _VT]) -> bool: ...
    async def msetnx(self, mapping: Dict[str, _VT]) -> bool: ...
    async def getset(self, name: str, value: _VT) -> Optional[_VT]: ...
    async def setnx(self, name: str, value: _VT) -> bool: ...
    async def setex(self, name: str, time: int, value: _VT) -> bool: ...
    async def psetex(self, name: str, time_ms: int, value: _VT) -> bool: ...
    
    async def publish(self, channel: str, message: _VT) -> int: ...
    
    async def close(self) -> None: ...
    async def connection_pool_get_connection(self, command_name: str, *keys: Any) -> Any: ...
    
    def pipeline(self, transaction: bool = True, shard_hint: Optional[str] = None) -> Any: ...

# Exceptions
class RedisError(Exception): ...
class ConnectionError(RedisError): ...
class TimeoutError(RedisError): ...
class ResponseError(RedisError): ...
class DataError(RedisError): ...
class PubSubError(RedisError): ...
class WatchError(RedisError): ...
class NoScriptError(ResponseError): ...
class ExecAbortError(ResponseError): ...
class ReadOnlyError(ResponseError): ...
class AuthenticationError(ConnectionError): ...
class BusyLoadingError(ConnectionError): ...
class InvalidResponse(ResponseError): ...
class AuthenticationWrongNumberOfArgsError(ResponseError): ...