# Type stubs for asyncpg
from typing import Any, Optional, Union, Dict, List, Tuple, Callable, Awaitable, Type
from typing_extensions import Self
import asyncio
from types import TracebackType

class Record:
    def __getitem__(self, key: Union[int, str]) -> Any: ...
    def __iter__(self) -> Any: ...
    def get(self, key: str, default: Any = None) -> Any: ...
    def keys(self) -> Any: ...
    def values(self) -> Any: ...
    def items(self) -> Any: ...

class Connection:
    async def execute(self, query: str, *args: Any, timeout: Optional[float] = None) -> str: ...
    async def executemany(self, query: str, args: List[Tuple[Any, ...]], *, timeout: Optional[float] = None) -> None: ...
    async def fetch(self, query: str, *args: Any, timeout: Optional[float] = None) -> List[Record]: ...
    async def fetchrow(self, query: str, *args: Any, timeout: Optional[float] = None) -> Optional[Record]: ...
    async def fetchval(self, query: str, *args: Any, column: int = 0, timeout: Optional[float] = None) -> Any: ...
    async def copy_from_table(self, table_name: str, *, output: Any, columns: Optional[List[str]] = None, schema_name: Optional[str] = None, timeout: Optional[float] = None) -> str: ...
    async def copy_to_table(self, table_name: str, *, source: Any, columns: Optional[List[str]] = None, schema_name: Optional[str] = None, timeout: Optional[float] = None) -> str: ...
    async def copy_from_query(self, query: str, *args: Any, output: Any, timeout: Optional[float] = None) -> str: ...
    async def copy_to_query(self, query: str, *args: Any, source: Any, timeout: Optional[float] = None) -> str: ...
    async def prepare(self, query: str, *, name: Optional[str] = None, timeout: Optional[float] = None) -> Any: ...
    async def close(self, timeout: Optional[float] = None) -> None: ...
    def transaction(self, *, isolation: Optional[str] = None, readonly: bool = False, deferrable: bool = False) -> Any: ...
    async def set_type_codec(self, typename: str, *, encoder: Callable[[Any], Any], decoder: Callable[[Any], Any], schema: str = "public", format: str = "text") -> None: ...
    async def reset(self, *, timeout: Optional[float] = None) -> None: ...
    def cursor(self, query: str, *args: Any, prefetch: Optional[int] = None, timeout: Optional[float] = None) -> Any: ...
    def is_closed(self) -> bool: ...
    async def reload_schema_state(self) -> None: ...
    def get_server_pid(self) -> int: ...
    def get_server_version(self) -> Any: ...
    def get_settings(self) -> Dict[str, str]: ...
    async def __aenter__(self) -> Self: ...
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], tb: Optional[TracebackType]) -> None: ...

class PoolConnectionProxy:
    async def execute(self, query: str, *args: Any, timeout: Optional[float] = None) -> str: ...
    async def executemany(self, query: str, args: List[Tuple[Any, ...]], *, timeout: Optional[float] = None) -> None: ...
    async def fetch(self, query: str, *args: Any, timeout: Optional[float] = None) -> List[Record]: ...
    async def fetchrow(self, query: str, *args: Any, timeout: Optional[float] = None) -> Optional[Record]: ...
    async def fetchval(self, query: str, *args: Any, column: int = 0, timeout: Optional[float] = None) -> Any: ...
    async def copy_from_table(self, table_name: str, *, output: Any, columns: Optional[List[str]] = None, schema_name: Optional[str] = None, timeout: Optional[float] = None) -> str: ...
    async def copy_to_table(self, table_name: str, *, source: Any, columns: Optional[List[str]] = None, schema_name: Optional[str] = None, timeout: Optional[float] = None) -> str: ...
    async def copy_from_query(self, query: str, *args: Any, output: Any, timeout: Optional[float] = None) -> str: ...
    async def copy_to_query(self, query: str, *args: Any, source: Any, timeout: Optional[float] = None) -> str: ...
    async def prepare(self, query: str, *, name: Optional[str] = None, timeout: Optional[float] = None) -> Any: ...
    def transaction(self, *, isolation: Optional[str] = None, readonly: bool = False, deferrable: bool = False) -> Any: ...
    async def set_type_codec(self, typename: str, *, encoder: Callable[[Any], Any], decoder: Callable[[Any], Any], schema: str = "public", format: str = "text") -> None: ...
    async def reset(self, *, timeout: Optional[float] = None) -> None: ...
    def cursor(self, query: str, *args: Any, prefetch: Optional[int] = None, timeout: Optional[float] = None) -> Any: ...
    def is_closed(self) -> bool: ...
    async def reload_schema_state(self) -> None: ...
    def get_server_pid(self) -> int: ...
    def get_server_version(self) -> Any: ...
    def get_settings(self) -> Dict[str, str]: ...

class Pool:
    async def acquire(self, *, timeout: Optional[float] = None) -> PoolConnectionProxy: ...
    async def release(self, connection: PoolConnectionProxy, *, timeout: Optional[float] = None) -> None: ...
    async def close(self) -> None: ...
    async def terminate(self) -> None: ...
    def set_connect_callback(self, callback: Callable[[Connection], Awaitable[None]]) -> None: ...
    def set_init_callback(self, callback: Callable[[Connection], Awaitable[None]]) -> None: ...
    async def execute(self, query: str, *args: Any, timeout: Optional[float] = None) -> str: ...
    async def executemany(self, query: str, args: List[Tuple[Any, ...]], *, timeout: Optional[float] = None) -> None: ...
    async def fetch(self, query: str, *args: Any, timeout: Optional[float] = None) -> List[Record]: ...
    async def fetchrow(self, query: str, *args: Any, timeout: Optional[float] = None) -> Optional[Record]: ...
    async def fetchval(self, query: str, *args: Any, column: int = 0, timeout: Optional[float] = None) -> Any: ...

class Transaction:
    async def __aenter__(self) -> Self: ...
    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc: Optional[BaseException], tb: Optional[TracebackType]) -> None: ...
    async def start(self) -> None: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...

class Cursor:
    def __aiter__(self) -> Self: ...
    async def __anext__(self) -> Record: ...
    async def fetch(self, n: int) -> List[Record]: ...
    async def fetchrow(self) -> Optional[Record]: ...
    async def forward(self, n: int) -> int: ...

# Connection functions
async def connect(
    host: Optional[str] = None,
    port: Optional[int] = None,
    user: Optional[str] = None,
    password: Optional[str] = None,
    database: Optional[str] = None,
    loop: Optional[asyncio.AbstractEventLoop] = None,
    timeout: Optional[float] = None,
    statement_cache_size: int = 100,
    max_cached_statement_lifetime: int = 300,
    max_cacheable_statement_size: int = 1024 * 15,
    command_timeout: Optional[float] = None,
    server_settings: Optional[Dict[str, str]] = None,
    ssl: Optional[Union[bool, str]] = None,
    **kwargs: Any
) -> Connection: ...

async def create_pool(
    dsn: Optional[str] = None,
    *,
    host: Optional[str] = None,
    port: Optional[int] = None,
    user: Optional[str] = None,
    password: Optional[str] = None,
    database: Optional[str] = None,
    loop: Optional[asyncio.AbstractEventLoop] = None,
    min_size: int = 10,
    max_size: int = 10,
    max_queries: int = 50000,
    max_inactive_connection_lifetime: float = 300.0,
    setup: Optional[Callable[[Connection], Awaitable[None]]] = None,
    init: Optional[Callable[[Connection], Awaitable[None]]] = None,
    timeout: Optional[float] = None,
    command_timeout: Optional[float] = None,
    server_settings: Optional[Dict[str, str]] = None,
    ssl: Optional[Union[bool, str]] = None,
    **kwargs: Any
) -> Pool: ...

# Exception classes
class PostgresError(Exception):
    sqlstate: Optional[str]

class InterfaceError(PostgresError): ...
class DataError(PostgresError): ...
class DatabaseError(PostgresError): ...
class IntegrityError(DatabaseError): ...
class InternalError(DatabaseError): ...
class NotSupportedError(DatabaseError): ...
class OperationalError(DatabaseError): ...
class ProgrammingError(DatabaseError): ...

class InvalidCatalogNameError(OperationalError): ...
class InvalidSchemaNameError(OperationalError): ...
class DuplicateDatabaseError(ProgrammingError): ...
class DuplicateSchemaError(ProgrammingError): ...
class DuplicateTableError(ProgrammingError): ...
class UndefinedTableError(ProgrammingError): ...
class UndefinedColumnError(ProgrammingError): ...
class UndefinedFunctionError(ProgrammingError): ...
class UniqueViolationError(IntegrityError): ...
class ForeignKeyViolationError(IntegrityError): ...
class CheckViolationError(IntegrityError): ...
class NotNullViolationError(IntegrityError): ...
class RestrictViolationError(IntegrityError): ...
class ExclusionViolationError(IntegrityError): ...

class PoolTimeoutError(asyncio.TimeoutError): ...
class TooManyConnectionsError(PostgresError): ...

# Utility functions
def set_exception_class(exc_class: Type[Exception]) -> None: ...